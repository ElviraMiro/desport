{"version":3,"sources":["cottz:publish-with-relations/handler_controller.js","cottz:publish-with-relations/publish.js","cottz:publish-with-relations/publish_relations.js","cottz:publish-with-relations/relations_methods.js","cottz:publish-with-relations/methods.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,oC;AACA,gB;AACA,oB;AACA,E;;AAEA,kE;AACA,oC;AACA,gE;AACA,4D;AACA,E;;AAEA,4C;AACA,e;AACA,oB;;AAEA,qC;;AAEA,gB;AACA,E;;AAEA,gD;AACA,8B;AACA,4B;AACA,uB;AACA,G;AACA,yC;AACA,mB;AACA,M;AACA,E;;;;;;;;;;;;;;;;;;AC5BA,yB;;AAEA,mE;AACA,oB;AACA,4D;AACA,+D;AACA,E;;AAEA,+D;AACA,+C;;AAEA,gC;AACA,uB;AACA,I;;AAEA,sB;AACA,E;;AAEA,sE;AACA,sD;;AAEA,gC;AACA,uB;AACA,I;;AAEA,sB;AACA,E;;AAEA,wB;;;;;;;;;;;;;;;;;;AC5BA,iE;AACA,mB;AACA,qC;AACA,kE;;AAEA,Y;AACA,mD;;AAEA,kD;AACA,gB;AACA,4C;AACA,a;AACA,wB;AACA,qB;AACA,sB;AACA,M;;AAEA,+E;AACA,G;;AAEA,gB;AACA,qC;AACA,M;AACA,mC;AACA,G;;AAEA,mD;AACA,6B;AACA,6B;AACA,I;AACA,+B;AACA,mE;AACA,4B;AACA,I;AACA,0B;AACA,yB;AACA,qB;AACA,wB;AACA,wB;AACA,I;AACA,G;AACA,I;;AAEA,yB;AACA,8B;;AAEA,6B;AACA,wB;AACA,I;;AAEA,gB;AACA,G;;AAEA,wB;AACA,2D;AACA,uB;AACA,S;AACA,kB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;AC3DA,4C;AACA,iC;;AAEA,uB;AACA,qB;AACA,yG;AACA,G;;AAEA,6C;AACA,E;;AAEA,gB;AACA,+B;;AAEA,wB;AACA,gC;AACA,E;;AAEA,sC;AACA,wC;AACA,uD;AACA,G;AACA,+C;AACA,8D;AACA,G;AACA,gC;AACA,2D;AACA,8C;AACA,+B;AACA,iD;;AAEA,kC;AACA,kB;AACA,sB;;AAEA,yD;AACA,G;;AAEA,mH;AACA,G;AACA,wF;AACA,0F;AACA,2D;AACA,qB;AACA,kB;AACA,oB;AACA,e;AACA,E;AACA,sC;AACA,gB;AACA,qB;AACA,uB;AACA,sB;AACA,I;AACA,G;;AAEA,uC;AACA,8B;AACA,sC;AACA,K;AACA,gC;AACA,6C;AACA,e;AACA,qC;AACA,K;AACA,2B;AACA,wC;AACA,e;AACA,qC;AACA,I;AACA,K;;AAEA,qC;AACA,gB;AACA,G;AACA,iE;AACA,mF;AACA,sC;AACA,iD;AACA,qB;AACA,kB;AACA,oB;AACA,e;;AAEA,e;AACA,2B;AACA,kC;AACA,G;AACA,E;AACA,gC;AACA,qC;AACA,c;AACA,qD;AACA,0C;AACA,U;AACA,qC;AACA,K;AACA,+C;AACA,Y;AACA,qD;;AAEA,6C;AACA,qB;;AAEA,8B;AACA,+B;;AAEA,uC;AACA,K;AACA,0C;AACA,+B;AACA,U;AACA,iD;AACA,I;AACA,K;;AAEA,qC;AACA,gB;AACA,G;AACA,sE;AACA,sF;AACA,kD;AACA,qB;AACA,kB;AACA,oB;AACA,G;AACA,iD;AACA,qC;AACA,oC;AACA,qB;AACA,oC;;AAEA,0C;;AAEA,sG;AACA,wC;AACA,yB;;AAEA,gC;AACA,Y;;AAEA,sF;AACA,2C;AACA,I;AACA,K;;AAEA,qC;AACA,0B;AACA,E;AACA,G;;;;;;;;;;;;;;;;;;ACrJA,gB;AACA,gD;AACA,uC;AACA,iD;AACA,sF;AACA,E;AACA,G","file":"/packages/cottz:publish-with-relations.js","sourcesContent":["HandlerController = function (_id) {\n\tthis._id = _id;\n\tthis.handlers = [];\n};\n\nHandlerController.prototype.add = function (observe, cursorName) {\n\tif(typeof cursorName != 'string') {\n\t\t// in this case the cursor was sent instead of the cursor name\n\t\tcursorName = cursorName._cursorDescription.collectionName;\n\t}\n\n\tvar oldHandler = this.handlers[cursorName];\n\tif(oldHandler)\n\t\toldHandler.stop();\n\n\tthis.handlers[cursorName] = observe;\n\n\treturn observe;\n};\n\nHandlerController.prototype.stop = function () {\n\tvar handlers = this.handlers;\n\tfor (var key in handlers) {\n\t\thandlers[key].stop();\n\t};\n\t//_.forIn(handlers, function (handler) {\n\t//\thandler.stop();\n\t//});\n};","publish = function () {};\n\npublish.prototype.cursor = function (cursor, sub, collectionName) {\n\tif(!collectionName)\n\t\tcollectionName = cursor._cursorDescription.collectionName;\n\tMeteor.Collection._publishCursor(cursor, sub, collectionName);\n};\n\npublish.prototype.observe = function (cursor, callbacks, sub) {\n\tvar observeHandle = cursor.observe(callbacks);\n\n\tsub && sub.onStop(function () {\n\t\tobserveHandle.stop();\n\t});\n\n\treturn observeHandle;\n};\n\npublish.prototype.observeChanges = function (cursor, callbacks, sub) {\n\tvar observeHandle = cursor.observeChanges(callbacks);\n\n\tsub && sub.onStop(function () {\n\t\tobserveHandle.stop();\n\t});\n\n\treturn observeHandle;\n};\n\nPublish = new publish();","publish.prototype.relations = function (sub, options, callback) {\n\tvar observes = [],\n\t\tcursor = options.cursor || options,\n\t\tname = options.name || cursor._cursorDescription.collectionName;\n\n\tif(!cursor)\n\t\tthrow new Error(\"you're not sending the cursor\");\n\n\tfunction _sendData (_id, parentDoc, addStarted) {\n\t\tif(callback) {\n\t\t\tvar methods = new RelationsMethods(_id, {\n\t\t\t\tsub: sub,\n\t\t\t\tstarted: addStarted,\n\t\t\t\tcursorName: name,\n\t\t\t\thandlers: observes\n\t\t\t});\n\n\t\t\tparentDoc = callback.call(methods, _id, parentDoc, addStarted) || parentDoc;\n\t\t}\n\n\t\tif(addStarted)\n\t\t\tsub.changed(name, _id, parentDoc);\n\t\telse\n\t\t\tsub.added(name, _id, parentDoc);\n\t};\n\n\tvar cursorObserveChanges = cursor.observeChanges({\n\t\tadded: function (id, doc) {\n\t\t\t_sendData(id, doc, false);\n\t\t},\n\t\tchanged: function (id, doc) {\n\t\t\t// the true is indicate to the callback that the doc has changed\n\t\t\t_sendData(id, doc, true);\n\t\t},\n\t\tremoved: function (id) {\n\t\t\tsub.removed(name, id);\n\t\t\tif(observes[id]) {\n\t\t\t\tobserves[id].stop();\n\t\t\t\tdelete observes[id];\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction stopCursor () {\n\t\tcursorObserveChanges.stop();\n\n\t\tfor (var key in observes) {\n\t\t\tobserves[key].stop();\n\t\t};\n\n\t\tobserves = [];\n\t};\n\n\tsub.onStop(stopCursor);\n\t// I do not think it necessary to send the Ready from here\n\t// return sub.ready();\n\treturn {\n\t\tstop: stopCursor\n\t};\n};","RelationsMethods = function (_id, options) {\n\tvar handlers = options.handlers;\n\n\tif(!options.started) {\n\t\tif(handlers[_id]) {\n\t\t\tconsole.log('there is already an observer with the id: ' + _id + ' in the cursorName: ' + cursorName);\n\t\t}\n\n\t\thandlers[_id] = new HandlerController(_id);\n\t}\n\n\tthis._id = _id;\n\tthis.handlers = handlers[_id];\n\n\tthis.sub = options.sub;\n\tthis.name = options.cursorName;\n};\n\n_.extend(RelationsMethods.prototype, {\n\tobserve: function (cursor, callbacks) {\n\t\tthis.handlers.add(cursor.observe(callbacks), cursor);\n\t},\n\tobserveChanges: function (cursor, callbacks) {\n\t\tthis.handlers.add(cursor.observeChanges(callbacks), cursor);\n\t},\n\t// make parameter is a callback\n\t// adds a new cursor in a different collection to the main\n\tcursor: function (cursor, cursorName, make) {\n\t\tvar handlers = this.handlers,\n\t\t\twithoutMake = typeof cursorName == 'function';\n\n\t\tif(!cursorName || withoutMake) {\n\t\t\tif(withoutMake)\n\t\t\t\tmake = cursorName;\n\n\t\t\tcursorName = cursor._cursorDescription.collectionName;\n\t\t}\n\n\t\treturn handlers.add(publish.prototype.relations(this.sub, {cursor: cursor, name: cursorName}, make), cursorName);\n\t},\n\t// designed to change something in the master document while the callbacks are executed\n\t// changes to the document are sent to the main document with the return of the callbacks\n\tchangeParentDoc: function (cursor, callbacks, onRemoved) {\n\t\tvar sub = this.sub,\n\t\t\t_id = this._id,\n\t\t\tname = this.name,\n\t\t\tresult = {};\n\t\t\n\t\tif(typeof callbacks == 'function') {\n\t\t\tcallbacks = {\n\t\t\t\tadded: callbacks,\n\t\t\t\tchanged: callbacks,\n\t\t\t\tremoved: onRemoved\n\t\t\t}\n\t\t}\n\n\t\tvar observe = cursor.observeChanges({\n\t\t\tadded: function (id, doc) {\n\t\t\t\tresult = callbacks.added(id, doc);\n\t\t\t},\n\t\t\tchanged: function (id, doc) {\n\t\t\t\tvar changes = callbacks.changed(id, doc);\n\t\t\t\tif(changes)\n\t\t\t\t\tsub.changed(name, _id, changes);\n\t\t\t},\n\t\t\tremoved: function (id) {\n\t\t\t\tvar changes = callbacks.removed(id);\n\t\t\t\tif(changes)\n\t\t\t\t\tsub.changed(name, _id, changes);\n\t\t\t}\n\t\t});\n\n\t\tthis.handlers.add(observe, cursor);\n\t\treturn result;\n\t},\n\t// returns an array of elements with all documents in the cursor\n\t// when there is a change it will update the element change in the resulting array\n\t// and send it back to the collection\n\tgroup: function (cursor, make, field, options) {\n\t\tvar sub = this.sub,\n\t\t\t_id = this._id,\n\t\t\tname = this.name,\n\t\t\tresult = [];\n\n\t\tif(options) {\n\t\t\tvar sort = options.sort,\n\t\t\t\tsortField = options.sortField;\n\t\t}\n\t\t\n\t\tvar observe = cursor.observe({\n\t\t\taddedAt: function (doc, atIndex) {\n\t\t\t\tif(sort) {\n\t\t\t\t\tatIndex = sort.indexOf(doc[sortField || '_id']);\n\t\t\t\t\tresult[atIndex] = make(doc, atIndex);\n\t\t\t\t} else\n\t\t\t\t\tresult.push(make(doc, atIndex));\n\t\t\t},\n\t\t\tchangedAt: function (doc, oldDoc, atIndex) {\n\t\t\t\tif(sort)\n\t\t\t\t\tatIndex = sort.indexOf(doc[sortField || '_id']);\n\n\t\t\t\tvar changes = make(doc, atIndex, oldDoc),\n\t\t\t\t\tchangesObj = {};\n\n\t\t\t\tresult[atIndex] = changes;\n\t\t\t\tchangesObj[field] = result;\n\n\t\t\t\tsub.changed(name, _id, changesObj);\n\t\t\t},\n\t\t\tremovedAt: function (oldDoc, atIndex) {\n\t\t\t\tvar cb = options.onRemoved;\n\t\t\t\tif(cb)\n\t\t\t\t\tsub.changed(name, _id, cb(oldDoc, atIndex));\n\t\t\t}\n\t\t});\n\n\t\tthis.handlers.add(observe, cursor);\n\t\treturn result;\n\t},\n\t// designed to paginate a list, works in conjunction with the methods\n\t// do not call back to the main callback, only the array is changed in the collection\n\tpaginate: function (fieldData, limit, infinite) {\n\t\tvar sub = this.sub,\n\t\t\t_id = this._id,\n\t\t\tname = this.name;\n\t\t\t\n\t\tvar crossbar = DDPServer._InvalidationCrossbar,\n\t\t\tfield = Object.keys(fieldData)[0],\n\t\t\tcopy = _.clone(fieldData)[field],\n\t\t\tmax = copy.length,\n\t\t\tconnectionId = sub.connection.id;\n\n\t\tfieldData[field] = copy.slice(0, limit);\n\n\t\tvar listener = crossbar.listen({connection: connectionId, _id: _id, field: field}, function (data) {\n\t\t\tif(connectionId == data.connection) {\n\t\t\t\tvar skip = data.skip;\n\n\t\t\t\tif(skip >= max && !infinite)\n\t\t\t\t\treturn;\n\n\t\t\t\tfieldData[field] = infinite ? copy.slice(0, skip): copy.slice(skip, skip + limit);\n\t\t\t\tsub.changed(name, data._id, fieldData);\n\t\t\t}\n\t\t});\n\n\t\tthis.handlers.add(listener, field);\n\t\treturn fieldData[field];\n\t}\n});","Meteor.methods({\n\tchangePagination: function (field, _id, skip) {\n\t\t// I want to know if this is reliable\n\t\tvar crossbar = DDPServer._InvalidationCrossbar;\n\t\tcrossbar.fire({connection: this.connection.id, field: field, _id: _id, skip: skip});\n\t}\n});"]}